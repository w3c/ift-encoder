edition = "2023";

import "util/segmentation_plan.proto";
import "util/common.proto";

// This messages provides the configuration details for closure_glyph_keyed_segmenter_util
//
// The closure_glyph_keyed_segmenter_util is used to turn a series of codepoint/feature based
// segments into a set of glyph based patches and activation conditions which respect a font's
// glyph substitution rules. This means that no matter what codepoints being rendered as long
// as the provided activation conditions are followed all needed glyphs will always be present.
//
// In addition to organizing the glyphs to respect substitution behaviour, the segmenter can
// also optionally try to optimize a glyph segmentation by selectively merging glyph patches
// together to reduce to the total number of patches and in turn the network overhead for loading
// them. In this configuration merging behaviour is primarily configured via the merge groups.
//
// Merging (if enabled) is done is three distinct phases (each is configured separately):
// 1. Preprocess merging: prior to glyph segmentation adjacent segments are merged together.
//    Configuration specifies how many input segments are merged to form each merged segment.
//    This is the cheapest type of merging, and since it happens prior to glyph segmentation
//    it reduces the computation cost of all subsequent operations.
//
// 2. Initial font merging: when enabled, after glyph segmentation all of the patches are
//    evaluated to see if it is beneficial to move their glyphs into the initial font and
//    remove the patch. For example consider a patch that is expected to be needed 100% of
//    the time. The overhead associated with the patch can be eliminated by moving it into
//    the initial font.
//
// 3. Patch merging: lastly, any remaining patches are evaluated to find cases where segments
//    can be merged together to improve the performance of the overall glyph segmentation.
//    Two different merge selection algorithms are currently supported: cost based and heuristic
//    The cost based approach evaluates potential merges agaisnt a cost function which utilizes
//    codepoint frequency data. Heuristic is a much faster appraoch, but does not make use of
//    frequency data. As a result it typically produces less optimal results. Primarily useful
//    when frequency data is not available.
message SegmenterConfig {

  // Specifies the set of codepoints and layout feature tags that should be placed into the
  // initial font, and hence be always available.
  SegmentProto initial_segment = 1;

  // Specifies what to do with unmapped glyphs. Unmapped glyphs are glyphs in which the analysis
  // is unable to determine activation conditions for.
  UnmappedGlyphHandling unmapped_glyph_handling = 2 [default = MOVE_TO_INIT_FONT];

  // If enabled then the generated segmentation plan will include a set of table keyed segments.
  // One table keyed segment will be generated per merge group, including the auto generated
  // ungrouped one.
  bool generate_table_keyed_segments = 3 [default = false];

  // The set of segments the font is initially broken up into. The key in the map is an ID
  // used to refer to the segment in other parts of the config. Segments must be disjoint.
  //
  // If this is not specified then a segmentation where each codepoint in the font is placed
  // into it's own segment will be used. In this case each segment id is the value of
  // the codepoint in that segment
  map<uint32, SegmentProto> segments = 4;

  // When utilizing automated segment generation ('segments' is unspecified), this provides
  // a list of feature groups that should be added to the automated segment list. Each group
  // will be one segment. These use their own id space separate from segments.
  map<uint32, Features> feature_segments = 5;

  // If true and feature_segments is not specified then TODO...
  bool generate_feature_segments = 14;

  // When generating compressed patches (to evaluate their size) this is the brotli quality
  // level used. Merge selection is typically bottle necked on brotli compression so higher
  // values increase processing times, but yield more accurate results.
  //
  // Value can from from 0 to 11. Higher numbers represent higher quality.
  //
  // If quality is set to '0' this disables brotli compression and instead estimates the
  // effect of compression using a fixed compression ratio calculated based on how well
  // the glyph data in the input font compresses.
  uint32 brotli_quality = 6 [default = 8];

  // During processing to determine which segments to move into the initial font this is
  // the brotli quality used for generating compressed patches (to evaluate their size).
  // The init font merge is more sensitive to lower brotli qualities, so this allows a higher
  // brotli quality to be used in this phase if desired.
  uint32 brotli_quality_for_initial_font_merging = 7 [default = 11];

  // These base configs define the common config setings used by the merge groups.
  // Each individual merge group's config is created by starting with the base config of the
  // matching type and then overiding any fields specified in the merge group config.
  HeuristicConfiguration base_heuristic_config = 8;
  CostConfiguration base_cost_config = 9;

  // If this is provided, then for any segments that are not covered by one of the merge groups
  // the heuristic merger will be used to group them according to this config. The heuristic
  // merger is used since for the ungrouped segments we do not have any available frequency data.
  //
  // Like the merge groups this config will be combined with base_heuristic_config.
  HeuristicConfiguration ungrouped_config = 10;

  // This is the group size (number of segments merged together) used in preprocess merging
  // of any segments not covered by a merge group. Setting to 1 disables preprocess merging
  // of ungrouped segments.
  uint32 preprocess_merging_group_size_for_ungrouped = 11 [default = 1];

  // Merge groups specify how merging will be performed for groups of segments.
  // Any segments that are not covered by any merge group will not be merged.
  // Merge groups are not required to be disjoint and may have overlapping segments.
  repeated MergeGroup merge_groups = 12;

  // When provide the generated segmentation plan will be merged onto this base plan.
  SegmentationPlan base_segmentation_plan = 13;

  // next = 15
}

// For a given set of segments this configures how merging will be performed. Each merge group
// is processed independently. Merges will only be made between things within the same group.
// Each merge group has it's own configuration and frequency data.
message MergeGroup {
  // Used to identify the group in logging.
  string name = 1;

  // The set of segments that this merge group covers. May overlap with other merge groups.
  // If this is not specified and a heuristic config is used, then it will default to all segments.
  // If this is not specified and a cost config is used, then this will default to the set of
  // segments the provided frequency data covers.
  SegmentsProto segment_ids = 2;

  // Adds in segments provided in the 'feature_segments' mapping.
  SegmentsProto feature_segment_ids = 3;

  // This is the group size (number of segments merged together) used in preprocess merging
  // of any segments covered by this merge group. Setting to 1 disables preprocess merging
  // of ungrouped segments.
  uint32 preprocess_merging_group_size = 4 [default = 1];

  // If frequency data is available only segments with probability less than this will
  // be included in the preprocess merging phase. Setting this to 1.0 will make preprocess
  // merging apply to all segments. Has no effect if this merge group is using heuristic
  // merging.
  double preprocess_merging_probability_threshold = 5 [default = 1.0];

  oneof config {
    HeuristicConfiguration heuristic_config = 6;
    CostConfiguration cost_config = 7;
  }
}

// The merger will choose segments to merge based on which combinations minimize a cost function.
// Here the cost function used is the average number of bytes transferred by a given segmentation.
// Codepoint frequency data is utilized to evaluate the cost function.
message CostConfiguration {

  oneof freq_data {
    // Path (relative to this configuration file) that points to Riegeli encoded frequency data
    // (using unicode_count.proto) that will be used during the evaluation of the cost function
    // for merging within this group. Must be provided.
    string path_to_frequency_data = 1;

    // Name (eg. "Script_latin.riegeli") of one of the data files from https://github.com/w3c/ift-encoder-data
    // For sharded files append a "@*" (eg. "Script_japanese.riegeli@*").
    string built_in_freq_data_name = 2;
  }

  // By default the cost function used for merging will utilize only individual codepoint probabilities
  // (ie. P(A)), when pair probabilities are needed it's assumed that individual probabilities are
  // all independent (ie. pair probabilities are given by P(A and B) = P(A) * P(B))
  //
  // If use_bigrams is enabled and the supplied frequency data contains codepoint pair frequencies
  // the the cost function will not assume independence and utilize the supplied pair frequencies.
  // This is much more accurate, but increase the computational complexity of the cost analysis
  // significantly.
  bool use_bigrams = 3 [default = false];

  // When evaluating the cost of each patch this is the estimated number of bytes of
  // network overhead for making the network request for the patch. Higher values encourage
  // more aggressive merging.
  uint32 network_overhead_cost = 4 [default = 75];

  // The minimum number of codepoints in each activation condition in the final segmentation.
  uint32 min_group_size = 5 [default = 1];

  // The set of segments whose total contributition to the total cost is less than this fraction
  // will have optimization skipped. This saves spending computation on segments that have very
  // little impact on the total cost of the segmentation. Higher values will cause more segments
  // to be cutoff.
  double optimization_cutoff_fraction = 6 [default = 0.001];

  // If the cost delta (bytes) to move a segment into the initial font is less than this value then,
  // it will be moved into the initial font. If this is left unset then nothing will be moved to the
  // init font for this group.
  double initial_font_merge_threshold = 7;

  // Segments below this probability will no be considered for moving into the initial font. This is
  // useful to prune segments from the analysis that are unlikely to be beneficial for moving.
  //
  // Value is from [0, 1].
  double initial_font_merge_probability_threshold = 8;

  // The merger prunes patch pairs from evaluation by looking at a "best case" cost reduction. During
  // this calculation the size of the merged patch is estimated using the size of the individual patches
  // being merged. The following forumula is used:
  //
  // merged_size =
  //   largest_individual_patch_size +
  //   best_case_size_reduction_fraction * sum of remaining patch sizes
  //
  // Where the individual patch sizes used are post compression. In affect this sets the lower bound for
  // how much merged data can shrink beyond it's initial compressed size (for the best case computation).
  //
  // The value is from [0, 1.0]. Lower values make best case pruning less aggressive, which means slower
  // run time but may lead to lower final segmentation costs. Higher values make best case pruning more
  // aggressive, which means faster run time but if it's set too high the merger may miss good merges.
  //
  // The current default value of 0.5 was selected by looking at the distribution of size reductions
  // in some example fonts. It was found (using brotli 9) that a only 0.2% of pairs have a reduction
  // less than 0.5. So 0.5 should typically have minimal impact on the final cost, while offering
  // a signficant run time speedup.
  //
  // TODO(garretrieger): evaluate this accross a larger sampling of fonts and brotli qualities to find a
  // more general default value.
  double best_case_size_reduction_fraction = 9 [default = 0.5];

  // By default merges under cost strategy are made by joining segments together, if this setting is
  // enabled than an alternate merge type, patch merge, will be considered by the merger. In a patch
  // merge glyphs from two patches are merged together along with the conditions for those patches.
  //
  // WARNING: This is currently defaulted off since there are some known issues with this approach
  // where shapers can make glyph substitutions that are not encoded in GSUB. When patch merges are
  // used it's possible to have a glyph included a patch, but under some subset definitions the glyph
  // is not actually reachable. Because it's not reachable it's dependencies may not have been loaded since
  // they aren't technically needed. However, in some cases such glyphs can be reached in practice by shaper
  // substitutions which the glyph closure doesn't take into acount (relevant harfbuzz issue:
  // https://github.com/harfbuzz/harfbuzz/issues/2283).
  //
  // Segment merges don't run into this issue since they will only ever include reachable glyphs
  // which means dependencies are always fully satisified. The shaper won't do substitutions if the appropriate
  // glyph isn't present.
  //
  // Work is planned to fix this issue (either in the harfbuzz closure or with a workaround in the segmenter),
  // until then it's recommended to not used this except for testing (or if appropriate care has been taken
  // in producing the input segments to avoid this issue).
  bool experimental_use_patch_merges = 10 [default = false];
}

// The merger will choose segments to merge based on a heuristic which primarily utilizes
// the input ordering of segments. It aims to get patch sizes somwhere between a supplied
// min and max value. It assumes the input segments are in frequency order (from most to least)
// by the given segment ids.
//
// This will often produce lower quality segmentations, but in many cases is much faster then cost
// based analysis.
message HeuristicConfiguration {
  // Segments will be merged to try and get patch sizes between this min and max.
  uint32 min_patch_size = 1 [default = 0];
  uint32 max_patch_size = 2 [default = 4294967295];
}