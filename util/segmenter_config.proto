edition = "2023";

import "util/common.proto";

// This messages provides the configuration details for closure_glyph_keyed_segmenter_util
message SegmenterConfig {

  // Specifies the set of codepoints and layout feature tags that should be placed into the
  // initial font, and hence be always available.
  SegmentProto initial_segment = 1;

  // When set any glyphs that would be in the fallback segment (ie. glyphs that are always loaded)
  // are moved into the initial font.
  bool move_fallback_glyphs_into_initial_font = 2 [default = true];

  // The set of segments the font is initially broken up into. The key in the map is an ID
  // used to refer to the segment in other parts of the config. Segments must be disjoint.
  //
  // If this is not specified then an initial segmentation where each codepoint in the font
  // is placed into it's own segment will be used. In this case each segment id is the value of
  // the codepoint in that segment
  map<uint32, SegmentProto> segments = 3;

  // When utilizing automated segment generation ('segments' is unspecified), this provides
  // a list of feature groups that should be added to the automated segment list. Each group
  // will be one segment. These use their own id space from segments.
  map<uint32, Features> feature_segments = 4;

  // When generating compressed patches (to evaluate their size) this is the brotli quality
  // level used. Segmentation is typically bottle necked on brotli compression so higher values
  // increase segmentation times, but yield more accurate results.
  uint32 brotli_quality = 5 [default = 8];

  // These base configs define the common config setings used by the merge groups.
  // Each individual merge groups config is created by starting with the base config of the
  // matching type and then overiding any fields specified in the merge group config.
  HeuristicConfiguration base_heuristic_config = 6;
  CostConfiguration base_cost_config = 7;

  // If this is provided, then for any segments that are not covered by one of the merge groups
  // the heuristic merger will be used to group them according to this config. The heuristic
  // merger is used since for the ungrouped segments we do not have any available frequency data.
  //
  // Like the merge groups this config will be combined with base_heuristic_config.
  HeuristicConfiguration ungrouped_config = 8;

  // Merge groups specify how merging will be performed for groups of segments.
  // Any segments that are not covered by any merge group will not be merged.
  // Merge groups are not required to be disjoint and may have overlapping segments.
  repeated MergeGroup merge_groups = 9;
}

// For a given set of segments this configures how merging will be performed. Each merge group
// is processed independently. Merges will only be made between things within the same group.
// Each merge group has it's own configuration and frequency data.
message MergeGroup {
  // The set of segments that this merge group covers. May overlap with other merge groups.
  // If this is not specified and a heuristic config is used, then it will default to all segments.
  // If this is not specified and a cost config is used, then this will default to the set of
  // segments the provided frequency data covers.
  SegmentsProto segment_ids = 1;

  // Adds in segments provided in the 'feature_segments' mapping.
  SegmentsProto feature_segment_ids = 2;

  oneof config {
    HeuristicConfiguration heuristic_config = 3;
    CostConfiguration cost_config = 4;
  }
}

// The merger will choose segments to merge based on which combinations minimize a cost function.
// Here the cost function used is the average number of bytes transferred by a given segmentation.
// Codepoint frequency data is utilized to evaluate the cost function.
message CostConfiguration {

  // Path (relative to this configuration file) that points to Riegeli encoded frequency data
  // (using unicode_count.proto) that will be used during the evaluation of the cost function
  // for merging within this group. Must be provided.
  string path_to_frequency_data = 1;

  // By default the cost function used for merging will utilize only individual codepoint probabilities
  // (ie. P(A)), when pair probabilities are needed it's assumed that individual probabilities are
  // all independent (ie. pair probabilities are given by P(A and B) = P(A) * P(B))
  //
  // If use_bigrams is enabled and the supplied frequency data contains codepoint pair frequencies
  // the the cost function will not assume independence and utilize the supplied pair frequencies.
  // This is much more accurate, but increase the computational complexity of the cost analysis
  // significantly.
  bool use_bigrams = 2 [default = false];

  // When evaluating the cost of each patch this is the estimated number of bytes of
  // network overhead for making the network request for the patch. Higher values encourage
  // more aggressive merging.
  uint32 network_overhead_cost = 3 [default = 75];

  // The minimum number of codepoints in each activation condition in the final segmentation.
  uint32 min_group_size = 4 [default = 1];

  // The set of segments whose total contributition to the total cost is less than this fraction
  // will have optimization skipped. This saves spending computation on segments that have very
  // little impact on the total cost of the segmentation. Higher values will cause more segments
  // to be cutoff.
  double optimization_cutoff_fraction = 5 [default = 0.001];

  // If the cost delta (bytes) to move a segment into the initial font is less than this value then,
  // it will be moved into the initial font. If this is left unset then nothing will be moved to the
  // init font for this group.
  double init_font_merge_threshold = 6;

  // Segments below this probability will no be considered for moving into the initial font. This is
  // useful to prune segments from the analysis that are unlikely to be beneficial for moving.
  //
  // Value is from [0, 1].
  double init_font_merge_probability_threshold = 7;

  // By default merges under cost strategy are made by joining segments together, if this setting is
  // enabled than an alternate merge type, patch merge, will be considered by the merger. In a patch
  // merge glyphs from two patches are merged together along with the conditions for those patches.
  //
  // WARNING: This is currently defaulted off since there are some known issues with this approach
  // where shapers can make glyph substitutions that are not encoded in GSUB. When patch merges are
  // used it's possible to have a glyph included a patch, but under some subset definitions the glyph
  // is not actually reachable. Because it's not reachable it's dependencies may not have been loaded since
  // they aren't technically needed. However, in some cases such glyphs can be reached in practice by shaper
  // substitutions which the glyph closure doesn't take into acount (relevant harfbuzz issue:
  // https://github.com/harfbuzz/harfbuzz/issues/2283).
  //
  // Segment merges don't run into this issue since they will only ever include reachable glyphs
  // which means dependencies are always fully satisified. The shaper won't do substitutions if the appropriate
  // glyph isn't present.
  //
  // Work is planned to fix this issue (either in the harfbuzz closure or with a workaround in the segmenter),
  // until then it's recommended to not used this except for testing (or if appropriate care has been taken
  // in producing the input segments to avoid this issue).
  bool experimental_use_patch_merges = 8 [default = false];
}

// The merger will choose segments to merge based on a heuristic which primarily utilizes
// the input ordering of segments. It aims to get patch sizes somwhere between a supplied
// min and max value. It assumes the input segments are in frequency order (from most to least)
// by the given segment ids.
//
// This will often produce lower quality segmentations, but in many cases is much faster then cost
// based analysis.
message HeuristicConfiguration {
  // Segments will be merged to try and get patch sizes between this min and max.
  uint32 min_patch_size = 1 [default = 0];
  uint32 max_patch_size = 2 [default = 4294967295];
}