#include "ift/encoder/glyph_groupings.h"

#include <optional>

#include "absl/container/btree_set.h"
#include "common/int_set.h"
#include "common/try.h"
#include "ift/encoder/glyph_closure_cache.h"
#include "ift/encoder/glyph_condition_set.h"
#include "ift/encoder/glyph_union.h"
#include "ift/encoder/requested_segmentation_information.h"
#include "ift/encoder/types.h"

using absl::btree_map;
using absl::btree_set;
using absl::flat_hash_map;
using absl::Status;
using absl::StatusOr;
using common::GlyphSet;
using common::SegmentSet;

namespace ift::encoder {

void GlyphGroupings::InvalidateGlyphInformation(
    const GlyphConditions& condition, uint32_t gid) {
  if (condition.and_segments.size() == 1) {
    segment_index_t s = *condition.and_segments.begin();
    exclusive_glyph_groups_[s].erase(gid);
    ActivationCondition activation_condition =
        ActivationCondition::exclusive_segment(s, 0);
    conditions_and_glyphs_[activation_condition].erase(gid);

    if (exclusive_glyph_groups_[s].empty()) {
      exclusive_glyph_groups_.erase(s);
      RemoveConditionAndGlyphs(activation_condition);
    }
  }

  auto it = and_glyph_groups_.find(condition.and_segments);
  if (it != and_glyph_groups_.end()) {
    it->second.erase(gid);
    ActivationCondition activation_condition =
        ActivationCondition::and_segments(condition.and_segments, 0);
    conditions_and_glyphs_[activation_condition].erase(gid);

    if (it->second.empty()) {
      and_glyph_groups_.erase(it);
      RemoveConditionAndGlyphs(activation_condition);
    }
  }

  it = or_glyph_groups_.find(condition.or_segments);
  if (it != or_glyph_groups_.end()) {
    it->second.erase(gid);
    ActivationCondition activation_condition =
        ActivationCondition::or_segments(condition.or_segments, 0);
    conditions_and_glyphs_[activation_condition].erase(gid);

    if (it->second.empty()) {
      or_glyph_groups_.erase(it);
      RemoveConditionAndGlyphs(activation_condition);
    }
  }

  unmapped_glyphs_.erase(gid);
}

static Status UnionGlyph(const GlyphSet& gids, glyph_id_t gid,
                         GlyphUnion& glyph_union) {
  if (gids.empty()) {
    return absl::OkStatus();
  }
  return glyph_union.Union(*gids.min(), gid);
}

Status GlyphGroupings::GroupGlyphs(
    const RequestedSegmentationInformation& segmentation_info,
    const GlyphConditionSet& glyph_condition_set,
    GlyphClosureCache& closure_cache, const GlyphSet& glyphs) {
  const auto& initial_closure = segmentation_info.InitFontGlyphs();

  // During the grouping process we also compute the "effective glyph union".
  // This takes manually supplied glyph unions (from the merging process)
  // and combines them with the gid partitioning specified by
  // glyph_condition_set. to form the effective partitioning that the final
  // patches generated by this process will follow.
  GlyphUnion effective_glyph_union = glyph_union_;
  SegmentSet modified_exclusive_segments;
  btree_set<SegmentSet> modified_and_groups;
  btree_set<SegmentSet> modified_or_groups;
  for (glyph_id_t gid : glyphs) {
    const auto& condition = glyph_condition_set.ConditionsFor(gid);

    if (!condition.and_segments.empty()) {
      if (condition.and_segments.size() == 1) {
        segment_index_t s = *condition.and_segments.begin();
        auto& gids = exclusive_glyph_groups_[s];
        TRYV(UnionGlyph(gids, gid, effective_glyph_union));
        gids.insert(gid);
        modified_exclusive_segments.insert(s);
      } else {
        // Note: the glyph union mechanism does not apply to conjunctive
        // conditions.
        and_glyph_groups_[condition.and_segments].insert(gid);
        modified_and_groups.insert(condition.and_segments);
      }
    }

    if (!condition.or_segments.empty()) {
      auto& gids = or_glyph_groups_[condition.or_segments];
      TRYV(UnionGlyph(gids, gid, effective_glyph_union));
      gids.insert(gid);
      modified_or_groups.insert(condition.or_segments);
    }

    if (condition.and_segments.empty() && condition.or_segments.empty() &&
        !initial_closure.contains(gid) &&
        segmentation_info.FullClosure().contains(gid)) {
      unmapped_glyphs_.insert(gid);
    }
  }

  TRYV(ExpandConditions(effective_glyph_union, modified_exclusive_segments,
                        modified_or_groups));

  for (segment_index_t s : modified_exclusive_segments) {
    auto condition = ActivationCondition::exclusive_segment(s, 0);
    AddConditionAndGlyphs(condition, exclusive_glyph_groups_[s]);
  }

  for (const auto& and_group : modified_and_groups) {
    auto condition = ActivationCondition::and_segments(and_group, 0);
    AddConditionAndGlyphs(condition, and_glyph_groups_[and_group]);
  }

  // Any of the or_set conditions we've generated may have some additional
  // conditions that were not detected. Therefore we need to rule out the
  // presence of these additional conditions if an or group is able to be
  // used.
  for (const auto& or_group : modified_or_groups) {
    auto& glyphs = or_glyph_groups_[or_group];

    SegmentSet all_other_segment_ids;
    if (!segmentation_info.Segments().empty()) {
      all_other_segment_ids.insert_range(
          0, segmentation_info.Segments().size() - 1);
      all_other_segment_ids.subtract(or_group);
    }

    GlyphSet or_gids = TRY(closure_cache.CodepointsToOrGids(
        segmentation_info, all_other_segment_ids));

    // Any "OR" glyphs associated with all other codepoints have some
    // additional conditions to activate so we can't safely include them into
    // this or condition. They are instead moved to the set of unmapped
    // glyphs.
    for (uint32_t gid : or_gids) {
      if (glyphs.erase(gid) > 0) {
        unmapped_glyphs_.insert(gid);
      }
    }

    ActivationCondition condition =
        ActivationCondition::or_segments(or_group, 0);
    if (glyphs.empty()) {
      // Group has been emptied out, so it's no longer needed.
      or_glyph_groups_.erase(or_group);
      RemoveConditionAndGlyphs(condition);
      continue;
    }

    AddConditionAndGlyphs(condition, glyphs);
  }

  for (uint32_t gid : unmapped_glyphs_) {
    // this glyph is not activated anywhere but is needed in the full closure
    // so add it to an activation condition of any segment.
    or_glyph_groups_[fallback_segments_].insert(gid);
  }

  // Note: we don't need to include the fallback segment/condition in
  //       conditions_and_glyphs since all downstream processing which
  //       utilizes that map ignores the fallback segment.

  return absl::OkStatus();
}

// Assuming that all members of 'gids' belong to the same union returns a
// representative gid for the set. Returns nullopt if gids is empty.
StatusOr<std::optional<uint32_t>> RepresentativeFor(
    const GlyphUnion& glyph_unions, const GlyphSet& gids) {
  // Since the assumes that all gids belong to the same union to find the
  // representative we need only check any single element of gids.
  auto gid = gids.min();
  if (!gid.has_value()) {
    return std::nullopt;
  }
  return TRY(glyph_unions.Find(*gid));
}

static Status UpdateReplacement(
    const GlyphUnion& glyph_unions, const SegmentSet& segments,
    const GlyphSet& gids,
    flat_hash_map<uint32_t, SegmentSet>& replacement_conditions) {
  std::optional<unsigned> representative =
      TRY(RepresentativeFor(glyph_unions, gids));
  if (representative.has_value()) {
    replacement_conditions[*representative].union_set(segments);
  }
  return absl::OkStatus();
}

// For the set of modified things use the glyph union to figure out if any
// conditions will be combined. Stores the replacement conditions as a map from
// each unions representative to the new set of segments for the new condition.
//
// For example if
// s1 -> {g1}
// s2 or s3 -> {g2, g3}
//
// And the union has {g1, g2, g3}
//
// Then this would compute a replacement condition of:
// g1 -> s1 or s2 or s3
//
// Where g1 is the representative for {g1, g2, g3}
Status GlyphGroupings::ComputeReplacementConditions(
    const GlyphUnion& glyph_unions,
    const SegmentSet& modified_exclusive_segments,
    const btree_set<SegmentSet>& modified_or_groups,
    flat_hash_map<uint32_t, SegmentSet>& replacement_conditions) const {
  for (segment_index_t s : modified_exclusive_segments) {
    auto gids = exclusive_glyph_groups_.find(s);
    if (gids == exclusive_glyph_groups_.end()) {
      return absl::InternalError("Unexpected missing exclusive glyph group.");
    }
    TRYV(UpdateReplacement(glyph_unions, SegmentSet{s}, gids->second,
                           replacement_conditions));
  }

  for (const auto& segments : modified_or_groups) {
    const auto& gids = or_glyph_groups_.find(segments);
    if (gids == or_glyph_groups_.end()) {
      return absl::InternalError("Unexpected missing or glyph group.");
    }
    TRYV(UpdateReplacement(glyph_unions, segments, gids->second,
                           replacement_conditions));
  }
  return absl::OkStatus();
}

// Apply the previously computed replacement conditions by swapping out any
// conditions who's representative is found in the replacement_conditions
// mapping. Swaps out the conditions from both the modified_* and
// *_glyph_groups_ datastructures.
Status GlyphGroupings::ReplaceConditions(
    const GlyphUnion& glyph_unions,
    const flat_hash_map<uint32_t, SegmentSet>& replacement_conditions,
    SegmentSet& modified_exclusive_segments,
    btree_set<SegmentSet>& modified_or_groups) {
  SegmentSet updated_modified_exclusive_segments;
  btree_set<SegmentSet> updated_modified_or_groups;

  // Exclusive Groups
  for (segment_index_t s : modified_exclusive_segments) {
    auto gids = exclusive_glyph_groups_.find(s);
    if (gids == exclusive_glyph_groups_.end()) {
      return absl::InternalError("Unexpected missing exclusive glyph group.");
    }

    std::optional<unsigned> representative =
        TRY(RepresentativeFor(glyph_unions, gids->second));
    if (!representative.has_value()) {
      continue;
    }

    auto new_segments = replacement_conditions.at(*representative);
    if (new_segments == SegmentSet{s}) {
      updated_modified_exclusive_segments.insert(s);
      continue;
    }

    // This exclusive segment is being replaced by a disjunctive condition.
    or_glyph_groups_[new_segments].union_set(gids->second);
    exclusive_glyph_groups_.erase(s);
    updated_modified_or_groups.insert(new_segments);
  }

  // Disjunctive Groups
  for (const SegmentSet& segments : modified_or_groups) {
    auto gids = or_glyph_groups_.find(segments);
    if (gids == or_glyph_groups_.end()) {
      return absl::InternalError("Unexpected missing or glyph group.");
    }

    std::optional<unsigned> representative =
        TRY(RepresentativeFor(glyph_unions, gids->second));
    if (!representative.has_value()) {
      continue;
    }

    auto new_segments = replacement_conditions.at(*representative);
    if (new_segments == segments) {
      updated_modified_or_groups.insert(segments);
      continue;
    }

    // The segment set for this is being expanded.
    or_glyph_groups_[new_segments].union_set(gids->second);
    or_glyph_groups_.erase(segments);
    updated_modified_or_groups.insert(new_segments);
  }

  modified_exclusive_segments = updated_modified_exclusive_segments;
  modified_or_groups = updated_modified_or_groups;

  return absl::OkStatus();
}

Status GlyphGroupings::ExpandConditions(
    const GlyphUnion& glyph_unions, SegmentSet& modified_exclusive_segments,
    btree_set<SegmentSet>& modified_or_groups) {
  // Overview:
  // 1. map from each union representative to the SegmentSet of all associated
  // segments.
  //    - Exclusive segments may be upgraded to OR's.
  // 2. Update both the "modified" and *_glyph_groups_ sets by applyling the
  // replacements (use the representative
  //    to find the replacement set.)
  //    - For exclusive segments, replacement means the exclusive group is
  //    removed and glyphs moved to the or_glyph_groups_.

  absl::flat_hash_map<unsigned, SegmentSet> replacement_conditions;
  TRYV(ComputeReplacementConditions(glyph_unions, modified_exclusive_segments,
                                    modified_or_groups,
                                    replacement_conditions));
  TRYV(ReplaceConditions(glyph_unions, replacement_conditions,
                         modified_exclusive_segments, modified_or_groups));

  return absl::OkStatus();
}

}  // namespace ift::encoder