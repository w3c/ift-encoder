#include "ift/encoder/glyph_groupings.h"

#include <optional>

#include "absl/container/btree_set.h"
#include "common/int_set.h"
#include "common/try.h"
#include "ift/encoder/activation_condition.h"
#include "ift/encoder/glyph_closure_cache.h"
#include "ift/encoder/glyph_condition_set.h"
#include "ift/encoder/glyph_union.h"
#include "ift/encoder/requested_segmentation_information.h"
#include "ift/encoder/types.h"

using absl::btree_map;
using absl::btree_set;
using absl::flat_hash_map;
using absl::Status;
using absl::StatusOr;
using common::GlyphSet;
using common::SegmentSet;

namespace ift::encoder {

void GlyphGroupings::InvalidateGlyphInformation(
    const GlyphConditions& condition, uint32_t gid) {
  if (condition.and_segments.size() == 1) {
    segment_index_t s = *condition.and_segments.begin();
    exclusive_glyph_groups_[s].erase(gid);
    ActivationCondition activation_condition = ActivationCondition::exclusive_segment(s, 0);
    conditions_and_glyphs_[activation_condition].erase(gid);

    if (exclusive_glyph_groups_[s].empty()) {
      exclusive_glyph_groups_.erase(s);
      RemoveConditionAndGlyphs(activation_condition);
    }
  }

  auto it = and_glyph_groups_.find(condition.and_segments);
  if (it != and_glyph_groups_.end()) {
    it->second.erase(gid);
    ActivationCondition activation_condition =
        ActivationCondition::and_segments(condition.and_segments, 0);
    conditions_and_glyphs_[activation_condition].erase(gid);

    if (it->second.empty()) {
      and_glyph_groups_.erase(it);
      RemoveConditionAndGlyphs(activation_condition);
    }
  }

  it = or_glyph_groups_.find(condition.or_segments);
  if (it != or_glyph_groups_.end()) {
    it->second.erase(gid);
    ActivationCondition activation_condition = ActivationCondition::or_segments(condition.or_segments, 0);
    conditions_and_glyphs_[activation_condition].erase(gid);

    if (it->second.empty()) {
      or_glyph_groups_.erase(it);
      RemoveConditionAndGlyphs(activation_condition);
    }
  }

  unmapped_glyphs_.erase(gid);

  // Any changes may affect in complex ways the expanded conditions
  // so remove them all. They will be fully recalculated during grouping.
  RemoveAllExpandedConditions();
}

// Removes conditions from conditions_and_glyphs_ which were generated by
// the condition expansion process.
void GlyphGroupings::RemoveAllExpandedConditions() {
  // expanded_or_glyph_groups_ provides a record of all expanded conditions.
  for (const auto& [segments, _] : expanded_or_glyph_groups_) {
    RemoveConditionAndGlyphs(ActivationCondition::or_segments(segments, 0));
  }
  expanded_or_glyph_groups_.clear();
}

Status GlyphGroupings::UnionPatches(const GlyphSet& a,
                                    const GlyphSet& b) {
  TRYV(glyph_union_.Union(a));
  TRYV(glyph_union_.Union(b));
  auto a_min = a.min();
  auto b_min = b.min();
  if (a_min.has_value() && b_min.has_value()) {
    TRYV(glyph_union_.Union(*a_min, *b_min));
  }

  RemoveAllExpandedConditions();

  return absl::OkStatus();
}

Status GlyphGroupings::GroupGlyphs(
    const RequestedSegmentationInformation& segmentation_info,
    const GlyphConditionSet& glyph_condition_set,
    GlyphClosureCache& closure_cache, const GlyphSet& glyphs) {
  const auto& initial_closure = segmentation_info.InitFontGlyphs();
  RemoveAllExpandedConditions();

  // During the grouping process we also compute the "effective glyph union".
  // This takes manually supplied glyph unions (from the merging process)
  // and combines them with the gid partitioning specified by
  // glyph_condition_set. to form the effective partitioning that the final
  // patches generated by this process will follow.
  SegmentSet modified_exclusive_segments;
  btree_set<SegmentSet> modified_and_groups;
  btree_set<SegmentSet> modified_or_groups;
  for (glyph_id_t gid : glyphs) {
    const auto& condition = glyph_condition_set.ConditionsFor(gid);

    if (!condition.and_segments.empty()) {
      if (condition.and_segments.size() == 1) {
        segment_index_t s = *condition.and_segments.begin();
        exclusive_glyph_groups_[s].insert(gid);
        modified_exclusive_segments.insert(s);
      } else {
        // Note: the glyph union mechanism does not apply to conjunctive
        // conditions.
        and_glyph_groups_[condition.and_segments].insert(gid);
        modified_and_groups.insert(condition.and_segments);
      }
    }

    if (!condition.or_segments.empty()) {
      or_glyph_groups_[condition.or_segments].insert(gid);
      modified_or_groups.insert(condition.or_segments);
    }

    if (condition.and_segments.empty() && condition.or_segments.empty() &&
        !initial_closure.contains(gid) &&
        segmentation_info.FullClosure().contains(gid)) {
      unmapped_glyphs_.insert(gid);
    }
  }

  for (segment_index_t s : modified_exclusive_segments) {
    auto condition = ActivationCondition::exclusive_segment(s, 0);
    AddConditionAndGlyphs(condition, exclusive_glyph_groups_[s]);
  }

  for (const auto& and_group : modified_and_groups) {
    auto condition = ActivationCondition::and_segments(and_group, 0);
    AddConditionAndGlyphs(condition, and_glyph_groups_[and_group]);
  }

  // Any of the or_set conditions we've generated may have some additional
  // conditions that were not detected. Therefore we need to rule out the
  // presence of these additional conditions if an or group is able to be
  // used.
  for (const auto& or_group : modified_or_groups) {
    auto& glyphs = or_glyph_groups_[or_group];

    SegmentSet all_other_segment_ids;
    if (!segmentation_info.Segments().empty()) {
      all_other_segment_ids.insert_range(
          0, segmentation_info.Segments().size() - 1);
      all_other_segment_ids.subtract(or_group);
    }

    GlyphSet or_gids = TRY(closure_cache.CodepointsToOrGids(
        segmentation_info, all_other_segment_ids));

    // Any "OR" glyphs associated with all other codepoints have some
    // additional conditions to activate so we can't safely include them into
    // this or condition. They are instead moved to the set of unmapped
    // glyphs.
    for (uint32_t gid : or_gids) {
      if (glyphs.erase(gid) > 0) {
        unmapped_glyphs_.insert(gid);
      }
    }

    ActivationCondition condition =
        ActivationCondition::or_segments(or_group, 0);
    if (glyphs.empty()) {
      // Group has been emptied out, so it's no longer needed.
      or_glyph_groups_.erase(or_group);
      RemoveConditionAndGlyphs(condition);
      continue;
    }

    AddConditionAndGlyphs(condition, glyphs);
  }

  // The expanded conditions can't be incrementally updated, so we recompute
  // them in full.
  TRYV(RecomputeExpandedConditions(glyph_condition_set));

  for (uint32_t gid : unmapped_glyphs_) {
    // this glyph is not activated anywhere but is needed in the full closure
    // so add it to an activation condition of any segment.
    or_glyph_groups_[fallback_segments_].insert(gid);
  }

  // Note: we don't need to include the fallback segment/condition in
  //       conditions_and_glyphs since all downstream processing which
  //       utilizes that map ignores the fallback segment.

  return absl::OkStatus();
}

// TODO XXXX review naming for this and sub methods.
Status GlyphGroupings::RecomputeExpandedConditions(const GlyphConditionSet& glyph_condition_set) {
  // To minimize the amount of work we need to do we first detect which segments are potentially
  // affected by the glyph union mechanism and then limit processing just to those.
  SegmentSet exclusive_segments;
  btree_set<SegmentSet> or_conditions;
  TRYV(ConditionsAffectedByUnion(glyph_condition_set, exclusive_segments, or_conditions));

  flat_hash_map<glyph_id_t, SegmentSet> merged_conditions;
  flat_hash_map<glyph_id_t, GlyphSet> merged_glyphs;
  TRYV(ComputeConditionExpansionMap(exclusive_segments, or_conditions, merged_conditions, merged_glyphs));

  for (const auto& [rep, segments] : merged_conditions) {
    const GlyphSet& gids = merged_glyphs.at(rep);
    ActivationCondition condition = ActivationCondition::or_segments(segments, 0);
    if (segments.size() == 1 && exclusive_segments.contains(*segments.min())) {
      // This is actually an exclusive condition, and is not expanded.
      condition = ActivationCondition::exclusive_segment(*segments.min(), 0);
    } else {
      SegmentSet segments_copy = segments;
      expanded_or_glyph_groups_[segments_copy] = gids;
    }

    AddConditionAndGlyphs(condition, gids);
  }

  return absl::OkStatus();
}

Status GlyphGroupings::ConditionsAffectedByUnion(
  const GlyphConditionSet& glyph_condition_set,
  SegmentSet& exclusive_segments,
  btree_set<SegmentSet>& or_conditions
) const {
  for (const GlyphSet& gids : TRY(glyph_union_.NonIdentityGroups())) {
    for (glyph_id_t gid : gids) {
      const auto& cond = glyph_condition_set.ConditionsFor(gid);
      if (cond.and_segments.size() == 1) {
        exclusive_segments.insert(*cond.and_segments.begin());
      }
      if (!cond.or_segments.empty()) {
        or_conditions.insert(cond.or_segments);
      }
    }
  }
  return absl::OkStatus();
}

Status GlyphGroupings::ComputeConditionExpansionMap(
    const SegmentSet& exclusive_segments,
    const btree_set<SegmentSet>& or_conditions,
    flat_hash_map<glyph_id_t, SegmentSet>& merged_conditions,
    flat_hash_map<glyph_id_t, GlyphSet>& merged_glyphs) {

  // Based on the disjunctive partition computes where conditions should
  // be replaced by an expanded condition. Replacement conditions map
  // from a representative glyph to the set of segments that form the
  // expanded condition.
  //
  // For example if
  // s1 -> {g1}
  // s2 or s3 -> {g2, g3}
  //
  // And the partition has {g1, g2, g3}
  //
  // Then this would compute a replacement condition of:
  // g1 -> s1 or s2 or s3
  //
  // Where g1 is the representative for {g1, g2, g3}

  // Form the complete partition incorporating glyph_union_ across all of the affected
  // groups.
  GlyphUnion partition = glyph_union_;
  for (segment_index_t s : exclusive_segments) {
    TRYV(partition.Union(exclusive_glyph_groups_.at(s)));
  }

  for (const auto& segments : or_conditions) {
    TRYV(partition.Union(or_glyph_groups_.at(segments)));
  }

  // Compute a map from partition representative to the fully expanded condition.
  for (segment_index_t s : exclusive_segments) {
    const GlyphSet& gids = exclusive_glyph_groups_.at(s);
    std::optional<glyph_id_t> first = gids.min();
    if (!first.has_value()) {
      continue;
    }

    glyph_id_t rep = TRY(partition.Find(*first));
    if (gids != TRY(partition.GlyphsFor(rep))) {
      // Only record cases where merges happen, if the glyph set is unmodifed
      // then there will be no merge.
      merged_conditions[rep].insert(s);
      merged_glyphs[rep].union_set(gids);
      RemoveConditionAndGlyphs(ActivationCondition::exclusive_segment(s, 0));
    } else {
      AddConditionAndGlyphs(ActivationCondition::exclusive_segment(s, 0), gids);
    }
  }

  for (const auto& segments : or_conditions) {
    const GlyphSet& gids = or_glyph_groups_.at(segments);
    std::optional<glyph_id_t> first = gids.min();
    if (!first.has_value()) {
      continue;
    }

    glyph_id_t rep = TRY(partition.Find(*first));
    if (gids != TRY(partition.GlyphsFor(rep))) {
      merged_conditions[rep].union_set(segments);
      merged_glyphs[rep].union_set(gids);
      RemoveConditionAndGlyphs(ActivationCondition::or_segments(segments, 0));
    } else {
      AddConditionAndGlyphs(ActivationCondition::or_segments(segments, 0), gids);
    }
  }

  return absl::OkStatus();
}

}  // namespace ift::encoder